[{"title":"Hello World","url":"/2024/01/09/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\n Run server\n$ hexo server\nMore info: Server\n Generate static files\n$ hexo generate\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"图论总结","url":"/2024/01/10/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/","content":" 图论\n\n 0.0.0.有感而发\n\n眼睛瞎了有利于打Dijkstra。 by NotDeep\n如果这题我不会做，那么一定是图论。 by NotDeep\n\n\n 1.1.1. 基本算法\n​\tCase 1:Case\\ 1:Case 1: Dijkstra\n​\t\t本质是 $贪心\\ +\\ DP $。\n​\t\t适用于非负权权图，保证当前取出的节点的最短路是确定的，是未确定最短路的节点中最小的。\n​\t\t常见题型 ： 补图，非负权图上用 ta ( SPFASPFASPFA已死 )。\n​\tCase 2:Case\\ 2:Case 2: Floyd\n​\t\t通过 O(n3)O(n^3)O(n3) 的时间求出任意两点的最短路。可以在负权图上使用。\n​\t\t可以求 最小环,传递闭包。\n​\t\t下面对最小环进行说明:\n//g[i][j]表示 i-&gt;j 的最短路,f[i][j]表示i-&gt;j的 边的长度//把最短路拆成 (i-j) + (i&gt;k,k-&gt;j)//用 dji 可以做到 O(m(n+m)log m)for(int k=1;k&lt;=n;k++)&#123;    for(int i=1;i&lt;=k-1;i++)        for(int j=i+1;j&lt;=k-1;j++)            ans=min(ans,f[i][k]+f[k][j]+g[i][j]);\tfor(int i=1;i&lt;=n;i++)\t\tfor(int j=1;j&lt;=n;j++)            g[i][j]=min(g[i][k]+g[k][j],g[i][j]);&#125;\n​\tCase 3:Case\\ 3:Case 3: Bellman–Ford\n​\t\t从 边 的角度考虑最短路：\n​\t\t\t最短路的边的个数 最多 是 n-1。\n​\t\t如果 边数 大于了 n-1 , 说明原图上有负环。\n​\t\t通过 for(i=1 → n)   for([u,v]∈E)  松弛for(i=1\\ \\rightarrow\\ n)\\ \\ \\ for([u,v] \\in E)\\ \\ 松弛for(i=1 → n)   for([u,v]∈E)  松弛 可以让每一条边都走过。\n​\t\t但实际上跑不满，所以有了 SPFASPFASPFA。\n​\tCase 4:Case\\ 4:Case 4: SPFA\n​\t\t对Case 3Case\\ 3Case 3的广搜优化，可以判负环。最坏 O(nm)O(nm)O(nm)。\n​\t\t优化点这儿。\n\n 2.2.2. 常见思路\n​\tCase 1:Case\\ 1:Case 1: 分层图最短路\n​\tCase 2:Case\\ 2:Case 2: Bellman–Ford 找负环\n​\tCase 3:Case\\ 3:Case 3: 跑完最短路后，在 最短路图(DAG) 上DPDPDP。\n​\tCase 4:Case\\ 4:Case 4: 多维最短路\n​\tCase 5:Case\\ 5:Case 5: 拆贡献/拆来源/YY长啥样\n\n 3.3.3. 魔改将至\n​\tCase 1:Case\\ 1:Case 1: 贪心\n​\t\t以摄像头问题2摄像头问题2摄像头问题2为例：\n​\t\t\t对于一段区间 [l,r][l,r][l,r] 我们连接一条 l→r+1l \\rightarrow r+1l→r+1 的边，在连接 i→i−1 ,i∈ni \\rightarrow i-1\\ ,i\\in ni→i−1 ,i∈n 。\n​\t\t\t令 distidist_idisti​ 表示覆盖区间 [1,i−1][1,i-1][1,i−1] 的代价，再跑最短路即可。\n​\tCase 2:Case\\ 2:Case 2: DPDPDP\n​\t\t以 Wi-Fi 为例：\n​\t\t\t我们把每种操作转换为 带权区间覆盖 ， 就转回了 摄像头2摄像头2摄像头2。\n\n\n 4.4.4. 题目详解\n 1.1.1. P4366P4366P4366\n​\t卡 O(mlog⁡m)O(m\\log m)O(mlogm) 的 dji 的题目少的很，遇见就要珍惜。\n​\t考虑异或性质：\nx⊕z=(x⊕y)⊕(y⊕z)&lt;=x⊕y+y⊕zx \\oplus z=(x\\oplus y) \\oplus (y\\oplus z)&lt;=x\\oplus y+y\\oplus z\nx⊕z=(x⊕y)⊕(y⊕z)&lt;=x⊕y+y⊕z\n​\t对于每个节点，拆成 32 个节点: {v∣v=x⊕2k,k∈N,v≤n}\\{v|v=x \\oplus2^k,k\\in N,v\\leq n\\}{v∣v=x⊕2k,k∈N,v≤n}，边数就会缩短成 nlog⁡n+mn\\log n+mnlogn+m。\n 2.2.2. 神秘力量\n​\t先对补图进行概念阐述：\n​\t\t完全图-现有图=现有图的补图\n​\t维护时可以用堆乱搞或用链表维护。分别为 O(mlog⁡m)O(m \\log m)O(mlogm) 和 O(n)O(n)O(n)。\n"}]